"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScopeWalker = void 0;
const Lint = require("tslint");
const tsutils = require("tsutils");
class ScopeWalker extends Lint.ProgramAwareRuleWalker {
    constructor() {
        super(...arguments);
        this.callbackMap = new Map();
        this.callbackStack = [];
        this.knownNames = {};
    }
    visitArrowFunction(node) {
        if (this.callbackMap.has(node)) {
            this.callbackStack.push(node);
            super.visitArrowFunction(node);
            this.callbackStack.pop();
        }
        else {
            super.visitArrowFunction(node);
        }
    }
    visitCallExpression(node) {
        const { arguments: args, expression } = node;
        let name;
        if (tsutils.isIdentifier(expression)) {
            name = expression.getText();
        }
        else if (tsutils.isPropertyAccessExpression(expression)) {
            const { name: propertyName } = expression;
            name = propertyName.getText();
        }
        const callbacks = args.filter((arg) => tsutils.isArrowFunction(arg) || tsutils.isFunctionExpression(arg));
        callbacks.forEach((callback) => this.callbackMap.set(callback, name));
        super.visitCallExpression(node);
        callbacks.forEach((callback) => this.callbackMap.delete(callback));
    }
    visitFunctionExpression(node) {
        if (this.callbackMap.has(node)) {
            this.callbackStack.push(node);
            super.visitFunctionExpression(node);
            this.callbackStack.pop();
        }
        else {
            super.visitFunctionExpression(node);
        }
    }
}
exports.ScopeWalker = ScopeWalker;
